title: 多核下高性能编程
date: 2014-12-26 16:14:52
tags: performance
categories: 编程
---
什么样的程序执行效率高？
程序的数据和指令都在cache中，没有cache miss出现。
所以如何让并行程序性能高基本可以演变成 如何减少cache miss？
尤其是多核下，并行程序cache的问题已经无法回避了，否则并行的效率还没有一个线程高。

借用一句歌词：**现在不是从前了，兔子比狐狸狡猾了**。

1.尽量避免全局变量，尤其是程序运行过程中可能修改的变量。所有线程只读的变量可以放松一丁点儿要求。全局变量是不保存在寄存器中的，所以如果一个函数中多次引用一个全局只读变量，那么可以在内部用一个局部变量先引用一下。
2.per thread per core。每个core运行一个线程，每个线程运行在一个cpu core上。
3.Keep data structures  per core。每个core仅仅修改自己的数据结构。
<!-- more -->
4.Keep data structures cache alignment。保证结构体定义的时候cache line对齐。可以自己添加pad，也可以用gcc提供的\__attribute__。
5.避免false sharing。
定义数据结构的时候不能这么搞： int num[CPU_NUMS]，这样在for循环中对num[i]++的时候就会造成false sharing。这也是为什么结构体定义要cache line对齐。
6.Lock-free data structures。
锁的代价是巨大的，搞不好还会死锁，多核间通信用lock-free fifo, 实在不行用CAS。
7.cpu affinity。
线程创建后立即绑定到具体的core上，然后再 进行分配内存，保证内存分配在自己的领土这边，如果内存分配超过总内存的一半，那么效率会大幅度降低，因为有一部分内存已经到了另一个cpu上了。
8.分支预测。使用gcc提供的likely和unlikely。
9.公共子表达式消除。一个函数中如果多次用到同一个表达式，可以开始的时候定义一个指针。
10.循环中消除指针引用。比如下面这样：
```
for(i=0; i< 1000; i++)
{
*dest++;
}
```
可以先定义一个局部变量进行累加，最后再把局部变量赋值给指针。
11.X86平台intel提供了很多的sse指令，尤其是在字符串的搜索和查找方面。
12.prefetch，gcc也提供了数据的预取指令，不过这个要对程序的执行流程和时间有非常好的把握，要不然预取到cache里用不到就没意思了。
13.多用perf tool和vtune。

暂时想到的先记录下来，找个时间给出具体的代码逐条举例说明一下。
强烈推荐《计算机体系结构量化研究方法》现在已经是第五版了，如果你想写的程序快，这本书里面有各种各样的技巧。
